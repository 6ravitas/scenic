defmodule Scenic.Template.Input.Checkbox do
  use Scenic.Template

  alias Scenic.Scene
  alias Scenic.Graph
  alias Scenic.Primitive
  alias Scenic.Primitive.Group
  alias Scenic.Primitive.Line
  alias Scenic.Primitive.Rectangle
  alias Scenic.Primitive.RoundedRectangle
  alias Scenic.Primitive.Text
  alias Scenic.Primitive.Style.Color
  alias Scenic.Primitive.Style.Hidden
  alias Scenic.Primitive.Style.LineWidth
  alias Scenic.Template.Input
  alias Scenic.Template.Input.Checkbox
  alias Scenic.Viewport.Input.Tracker

#  import IEx

  @default_radius     3

  @text_color         Color.build( :white )
  @box_color          Color.build( :antique_white )
  @check_color        Color.build( :cornflower_blue )

  @hidden             Hidden.build( true )
  @showing            Hidden.build( false )

  @hit_target_color   Color.build( {:dark_green, 0} )

  #----------------------------------------------------------------------------
  def build(data, opts \\ [] )

  def build({chx, text}, opts ) when is_boolean(chx) and is_bitstring(text) do
    r = opts[:r] || opts[:radius] || @default_radius

    check_styles = case chx do
      true ->   [@check_color, @showing, LineWidth.build(2)]
      false ->  [@check_color, @hidden]
    end

    # build the button graph
    Input.build( Keyword.put(opts, :value, chx) )
      |> Graph.put_new( 0, Rectangle.build({{-2,-2}, 140, 16}, styles: [@hit_target_color]) )
      |> Graph.put_new( 0, RoundedRectangle.build({{0,0}, 12, 12, r}, styles: [@box_color]) )

      |> Graph.put_new( 0, Group.build(tags: [:checkmark], styles: check_styles), fn(graph, parent) ->
        graph
        |> Graph.put_new( parent, Line.build({{2,2}, {10,10}}) )
        |> Graph.put_new( parent, Line.build({{2,10}, {10,2}}) )
      end)

      |> Graph.put_new( 0, Text.build({{16,11}, text}, styles: [@text_color]) )
      |> Graph.put_event_filter(0, {Checkbox, :filter_input})
  end



  #----------------------------------------------------------------------------
  def filter_input(event, id, checkbox, graph) do
    case event do

      {:mouse_down, _ } ->
        {:ok,_} = Tracker.Click.start_link(
          id, Primitive.get_uid( checkbox ),
          Group.get( checkbox )
        )
        {:stop,  graph}

      {:click, id, uid } ->
        # find the checkmark for this checkbox
        checkbox_uid = Primitive.get_uid( checkbox )
        [checkmark] = Graph.find(graph, checkbox_uid, tag: :checkmark)
        checkmark_uid = Primitive.get_uid( checkmark )

        new_hidden = !Hidden.get( Primitive.get_style(checkmark, Hidden) )

        graph = case new_hidden do
          true ->
            Scene.send_input( self(), {:value_changed, id, uid, false}, checkbox_uid )
            Graph.put_style(graph, checkmark_uid, @hidden)
          false ->
            Scene.send_input( self(), {:value_changed, id, uid, true}, checkbox_uid )
            Graph.put_style(graph, checkmark_uid, @showing)
        end
        {:stop,  graph}

      event ->
        {:continue, event, graph}
    end
  end

end